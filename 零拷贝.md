# 零拷贝

## 名词介绍

### 用户态内核态

- 如果进程运行于用户空间，被称为进程的用户态
- 如果进程运行于内核空间，被称为进程的内核态

指令区分
- 特权指令：只能由操作系统使用、用户程序不能使用的指令。 举例：启动I/O 内存清零 修改程序状态字 设置时钟 允许/禁止终端 停机
- 非特权指令：用户程序可以使用的指令。 举例：控制转移 算数运算 取数指令 访管指令（使用户程序从用户态陷入内核态）

这两种状态的主要差别是
- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
- 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

### CPU上下文

CPU寄存器，是CPU内置的容量小、但速度极快的内存。

程序计数器，是用来存储 CPU正在执行的指令位置、或者即将执行的下一条指令位置。

它们都是CPU在运行任何任务前，必须的依赖环境，因此叫做CPU上下文。

### CPU上下文切换

CPU上下文切换是指，先把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来

然后加载新任务的上下文到这些寄存器和程序计数器

最后再跳转到程序计数器所指的新位置，运行新任务。

### DMA

英文全称是Direct Memory Access，即直接内存访问。DMA本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程不需要CPU的参与。

主要就是帮亡CPU传发一下IO请求，以及考贝数据。

### 虚拟内存

现代操作系统使用虚拟内存，即虚拟地址取代物理地址，使用虚拟内存可以有2个好处：

- 虚以内存空间可以远远大于物理内存空间（Swap分区）
- 多个虚拟内存可以指向同一个物理地址

正是多个虚拟内存可以指向同一个物理地址，可以把内核空间和用户空间的虚拟地址映射到
同一个物理地址，这样就可以减少数据拷贝次数

## 传统IO流程

```plantuml
Title: 传统IO流程
autonumber
participant 客户端 as U
participant 用户态 as A
participant 内核态 as K    
participant DMA控制器 as D
participant 硬件设备 as E

U -> A: 读取数据请求
A -> K: read请求,上下文切换1
K -> D: 读取磁盘请求
D -> E: 态读取磁盘
E -> D: 返回磁盘数据
D -> K: DMA拷贝1
K -> A: CPU拷贝1，上下文切换2
A -> K: write请求,CPU拷贝2，上下文切换3
K -> D: 写数据请求，DMA拷贝2
D -> E: 写数据到网卡
E -> U: 网卡传输数据到客户端
```

客户端请求文件:
1. 用户应用进程收到客户端请求，用户应用进程调用read函数，向操作系统发起IO调用(第一次上下文切换)
2. CPU收到指令后，对DMA控制器发起指令调度。
3. DMA收到IO请求后，将请求发送给磁盘；
4. 磁盘将数据放入磁盘控制缓中区，并通知DMA 
5. DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。（第一次DMA复制）
6. DMA向CPU发出数据读完的信号，把工作交换给CPU，由CPU负贵将数据从内核缓中区拷贝到用户缓冲区。(第一次CPU拷贝)
7. 用户应用进程由内核态切换回用户态，解除阻塞状态(第二次上下文切换)
8. 用户应用进程拿到数据返回客户端，调用write函数，向操作系统发起IO调用(第三次上下文切换)
9. CPU从用户缓冲区中的数据放入socket缓冲区(第二次CPU拷贝)
10. CPU通知DMA将数据通过网卡发送出去
11. DMA从socket缓冲区将数据发送给网卡(第二次DMA复制）
12. 流程结束，由内核态转变为用户态(第四次上下文切换)

总共4次上下文切换，4次数据拷贝（2次DMA拷贝2次CPU拷贝）

## mmap + write

mmap是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享。

所以节省了一次CPU拷贝，并且用户进程内存是虚拟的，只是映射到内核的读缓冲区，可以节省一半的内存空间。

客户端请求文件:
1. 用户应用进程收到客户端请求，用户应用进程调用mmap函数(将内核缓冲区的数据映射到用户缓冲区)，向操作系统发起IO调用(第一次上下文切换)
2. CPU收到指令后，对DMA控制器发起指令调度。
3. DMA收到IO请求后，将请求发送给磁盘；
4. 磁盘将数据放入磁盘控制缓中区，并通知DMA
5. DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。（第一次DMA复制）
6. DMA向CPU发出数据读完的信号，把工作交换给CPU，此时内核缓冲区与用户缓冲区已有映射关系所以不需要数据拷贝
7. 用户应用进程由内核态切换回用户态，解除阻塞状态(第二次上下文切换)
8. 用户应用进程拿到数据返回客户端，调用write函数，向操作系统发起IO调用(第三次上下文切换)
9. CPU从内核缓冲区将数据放入socket缓冲区(第一次CPU拷贝)
10. CPU通知DMA将数据通过网卡发送出去
11. DMA从socket缓冲区将数据发送给网卡(第二次DMA复制）
12. 流程结束，由内核态转变为用户态(第四次上下文切换)

总共4次上下文切换，3次数据拷贝（2次DMA拷贝1次CPU拷贝）

## sendfile(2.1内核)

通过sendfile系统函数直接替换了mmap和write，这样就只有一次系统调用，减少了2次上下文切换（因为一次系统调用有两次上下文切换）

客户端请求文件:
1. 用户应用进程收到客户端请求，用户应用进程调用sendfile函数，向操作系统发起IO调用(第一次上下文切换)
2. CPU收到指令后，对DMA控制器发起指令调度。
3. DMA收到IO请求后，将请求发送给磁盘；
4. 磁盘将数据放入磁盘控制缓中区，并通知DMA
5. DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。（第一次DMA复制）
6. DMA向CPU发出数据读完的信号，把工作交换给CPU
7. CPU将内核缓冲区数据拷贝到socket缓冲区(第一次CPU拷贝)
8. CPU通知DMA将数据通过网卡发送出去
9. DMA从socket缓冲区将数据发送给网卡(第二次DMA复制）
10. 流程结束，由内核态转变为用户态(第二次上下文切换)

总共2次上下文切换，3次数据拷贝（2次DMA拷贝1次CPU拷贝）

## sendfile(2.4内核)

对于网卡支持SG-DMA技术的情况下，CPU不在将数据拷贝到socket缓冲区，而是直接从内核缓冲区发送到网卡。

这样又减少了一次CPU数据拷贝。所以这其中只有CPU调度二没有CPU拷贝极大提高了性能

客户端请求文件:
1. 用户应用进程收到客户端请求，用户应用进程调用sendfile函数，向操作系统发起IO调用(第一次上下文切换)
2. CPU收到指令后，对DMA控制器发起指令调度。
3. DMA收到IO请求后，将请求发送给磁盘；
4. 磁盘将数据放入磁盘控制缓中区，并通知DMA
5. DMA将数据从磁盘控制器缓冲区拷贝到内核缓冲区。（第一次DMA复制）
6. DMA向CPU发出数据读完的信号，把工作交换给CPU
7. CPU通知DMA将数据通过网卡发送出去
8. DMA从内核缓冲区将数据发送给网卡(第二次DMA复制）
9. 流程结束，由内核态转变为用户态(第二次上下文切换)

总共2次上下文切换，2次数据拷贝（2次DMA拷贝0次CPU拷贝）

## 零拷贝的好处

- 减少甚至完全避免不必要的CPU拷贝，从而让CPU解脱出来去执行其他的任务
- 减少内存带宽的占用
- 通常零拷贝枝术还能够减少用户空间和操作系统内核空间之间的上下文切换

